<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <title>Google Maps</title>
        <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBxmF8yMl0hBcK2-YnKpdB16V50ZOhcq_M&sensor=false&callback=initMap"
      async defer></script>
    <style type="text/css">
      <!--
        body {
          font: 14px "Trebuchet MS", Verdana, sans-serif;          background: #FFFFCC;        }
        .style1 {font-size: 18px}
        -->
    </style>
  </head>
  <body>
    <div align="center">
      <div id="controls">
        <form onsubmit="start();return false">
          Enter start and end addresses.<br />
          <strong> This example journey takes us from Patrick's St, Cork, Ireland to The Square, Blarney, Cork, Ireland.</strong><br />
          Based on Google Maps Latitude, Longitude... just press the start button<br />
          <input type="text" size="80" maxlength="200" id="startpoint" value="Patrick's St, Cork, Ireland" /><br />
          <input type="text" size="80" maxlength="200" id="endpoint" value="The Square, Blarney, Cork, Ireland" /><br />
          <!-- <input type="text" size="80" maxlength="200" id="startpoint" value="51.942638,-7.858014" /><br>
            <input type="text" size="80" maxlength="200" id="endpoint" value="52.009586,-7.912860" /><br> -->
          <input type="submit" value="Start"  />
        </form>
      </div>
      <div id="map" style="width: 800px; height: 400px"></div>
      <div class="style1" id="step">&nbsp;</div>
      <div class="style1" id="distance">Miles: 0.00</div>
      <span class="style1">
        <script type="text/javascript">
          //<![CDATA[
            google.maps.Polygon.prototype.Contains = function(point) {
                var j = 0;
                var oddNodes = false;
                var x = point.lng();
                var y = point.lat();
                for (var i = 0; i < this.getVertexCount(); i++) {
                    j++;
                    if (j == this.getVertexCount()) {
                        j = 0;
                    }
                    if (((this.getVertex(i).lat() < y) && (this.getVertex(j).lat() >= y)) || ((this.getVertex(j).lat() < y) && (this.getVertex(i).lat() >= y))) {
                        if (this.getVertex(i).lng() + (y - this.getVertex(i).lat()) / (this.getVertex(j).lat() - this.getVertex(i).lat()) * (this.getVertex(j).lng() - this.getVertex(i).lng()) < x) {
                            oddNodes = !oddNodes
                        }
                    }
                }
                return oddNodes;
            }

            // === A method which returns the approximate area of a non-intersecting polygon in square metres ===
            // === It doesn't fully account for spechical geometry, so will be inaccurate for large polygons ===
            // === The polygon must not intersect itself ===
            google.maps.Polygon.prototype.Area = function() {
                var a = 0;
                var j = 0;
                var b = this.Bounds();
                var x0 = b.getSouthWest().lng();
                var y0 = b.getSouthWest().lat();
                for (var i = 0; i < this.getVertexCount(); i++) {
                    j++;
                    if (j == this.getVertexCount()) {
                        j = 0;
                    }
                    var x1 = this.getVertex(i).distanceFrom(new google.maps.LatLng(this.getVertex(i).lat(), x0));
                    var x2 = this.getVertex(j).distanceFrom(new google.maps.LatLng(this.getVertex(j).lat(), x0));
                    var y1 = this.getVertex(i).distanceFrom(new google.maps.LatLng(y0, this.getVertex(i).lng()));
                    var y2 = this.getVertex(j).distanceFrom(new google.maps.LatLng(y0, this.getVertex(j).lng()));
                    a += x1 * y2 - x2 * y1;
                }
                return Math.abs(a * 0.5);
            }

            // === A method which returns the length of a path in metres ===
            google.maps.Polygon.prototype.Distance = function() {
                var dist = 0;
                for (var i = 1; i < this.getVertexCount(); i++) {
                    dist += this.getVertex(i).distanceFrom(this.getVertex(i - 1));
                }
                return dist;
            }

            // === A method which returns the bounds as a GLatLngBounds ===
            google.maps.Polygon.prototype.Bounds = function() {
                var bounds = new google.maps.LatLngBounds();
                for (var i = 0; i < this.getVertexCount(); i++) {
                    bounds.extend(this.getVertex(i));
                }
                return bounds;
            }

            // === A method which returns a GLatLng of a point a given distance along the path ===
            // === Returns null if the path is shorter than the specified distance ===
            google.maps.Polygon.prototype.GetPointAtDistance = function(metres) {
                // some awkward special cases
                if (metres == 0) return this.getVertex(0);
                if (metres < 0) return null;
                var dist = 0;
                var olddist = 0;
                for (var i = 1;
                    (i < this.getVertexCount() && dist < metres); i++) {
                    olddist = dist;
                    dist += this.getVertex(i).distanceFrom(this.getVertex(i - 1));
                }
                if (dist < metres) {
                    return null;
                }
                var p1 = this.getVertex(i - 2);
                var p2 = this.getVertex(i - 1);
                var m = (metres - olddist) / (dist - olddist);
                return new google.maps.LatLng(p1.lat() + (p2.lat() - p1.lat()) * m, p1.lng() + (p2.lng() - p1.lng()) * m);
            }

            // === A method which returns the Vertex number at a given distance along the path ===
            // === Returns null if the path is shorter than the specified distance ===
            google.maps.Polygon.prototype.GetIndexAtDistance = function(metres) {
                // some awkward special cases
                if (metres == 0) return this.getVertex(0);
                if (metres < 0) return null;
                var dist = 0;
                var olddist = 0;
                for (var i = 1;
                    (i < this.getVertexCount() && dist < metres); i++) {
                    olddist = dist;
                    dist += this.getVertex(i).distanceFrom(this.getVertex(i - 1));
                }
                if (dist < metres) {
                    return null;
                }
                return i;
            }

            // === A function which returns the bearing between two vertices in decgrees from 0 to 360===
            // === If v1 is null, it returns the bearing between the first and last vertex ===
            // === If v1 is present but v2 is null, returns the bearing from v1 to the next vertex ===
            // === If either vertex is out of range, returns void ===
            google.maps.Polygon.prototype.Bearing = function(v1, v2) {
                    if (v1 == null) {
                        v1 = 0;
                        v2 = this.getVertexCount() - 1;
                    } else if (v2 == null) {
                        v2 = v1 + 1;
                    }
                    if ((v1 < 0) || (v1 >= this.getVertexCount()) || (v2 < 0) || (v2 >= this.getVertexCount())) {
                        return;
                    }
                    var from = this.getVertex(v1);
                    var to = this.getVertex(v2);
                    if (from.equals(to)) {
                        return 0;
                    }
                    var lat1 = from.latRadians();
                    var lon1 = from.lngRadians();
                    var lat2 = to.latRadians();
                    var lon2 = to.lngRadians();
                    var angle = -Math.atan2(Math.sin(lon1 - lon2) * Math.cos(lat2), Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));
                    if (angle < 0.0) angle += Math.PI * 2.0;
                    angle = angle * 180.0 / Math.PI;
                    return parseFloat(angle.toFixed(1));
                }
                // === Copy all the above functions to GPolyline ===
            google.maps.Polyline.prototype.Contains = google.maps.Polygon.prototype.Contains;
            google.maps.Polyline.prototype.Area = google.maps.Polygon.prototype.Area;
            google.maps.Polyline.prototype.Distance = google.maps.Polygon.prototype.Distance;
            google.maps.Polyline.prototype.Bounds = google.maps.Polygon.prototype.Bounds;
            google.maps.Polyline.prototype.GetPointAtDistance = google.maps.Polygon.prototype.GetPointAtDistance;
            google.maps.Polyline.prototype.GetIndexAtDistance = google.maps.Polygon.prototype.GetIndexAtDistance;
            google.maps.Polyline.prototype.Bearing = google.maps.Polygon.prototype.Bearing;
          
          function initMap(){
              var map = new google.maps.Map(document.getElementById("map"),{
                center: {lat: 52.520007, lng: 13.404954},
                zoom: 10,
                mapTypeControl : true
              });       
              var step = 10; // metres
            
              var tick = 50; // milliseconds
            
              var poly;          
              var eol;          
                      var marker = new google.maps.Marker({
          map: map,
          position: {lat:41.85, lng: -87.65},
          icon: '/static/jan-64.png',
          title: 'Jan'
        });
              var car = new google.maps.Marker({          
                    map: map,
                    position: {lat:41.85, lng: -87.65},
                    icon: '/static/jan-64.png',
                    title: 'Jan' 
                  });      
              var marker;          
              var k=0;          
              var stepnum=0;          
              var speed = "";          
          
            function animate(d) {
          
              if (d>eol) {
          
                document.getElementById("step").innerHTML = "<b>Trip completed</b>";          
                document.getElementById("distance").innerHTML =  "Miles: "+(d/1609.344).toFixed(2);          
                return;          
              }
          
              var p = poly.GetPointAtDistance(d);          
              if (k++>=180/step) {
          
                map.panTo(p);          
                k=0;          
              }
          
              marker.setPoint(p);          
              document.getElementById("distance").innerHTML =  "Miles: "+(d/1609.344).toFixed(2)+speed;          
              if (stepnum+1 < map.direction.getRoute(0).getNumSteps()) {
          
                if (dirn.getRoute(0).getStep(stepnum).getPolylineIndex() < poly.GetIndexAtDistance(d)) {
          
                  stepnum++;          
                  var steptext = map.direction.getRoute(0).getStep(stepnum).getDescriptionHtml();          
                  document.getElementById("step").innerHTML = "<b>Next:</b> "+steptext;          
                  var stepdist = map.direction.getRoute(0).getStep(stepnum-1).getDistance().meters;          
                  var steptime = map.direction.getRoute(0).getStep(stepnum-1).getDuration().seconds;          
                  var stepspeed = ((stepdist/steptime) * 2.24).toFixed(0);          
                  step = stepspeed/2.5;          
                  speed = "<br>Current speed: " + stepspeed +" mph";          
                }
          
              } else {
          
                if (map.direction.getRoute(0).getStep(stepnum).getPolylineIndex() < poly.GetIndexAtDistance(d)) {
          
                  document.getElementById("step").innerHTML = "<b>Next: Arrive at your destination</b>";          
                }
          
              }
          
              setTimeout("animate("+(d+step)+")", tick);          
            }
          
          
          
            google.maps.event.addListener(map.direction,"load", function() {
          
              document.getElementById("controls").style.display="none";          
              poly=map.direction.getPolyline();          
              eol=poly.Distance();          
              map.setCenter(poly.getVertex(0),17);          
              map.addOverlay(new google.maps.Marker(poly.getVertex(0),G_START_ICON));          
              map.addOverlay(new google.maps.Marker(poly.getVertex(poly.getVertexCount()-1),G_END_ICON));          
              marker = new google.maps.Marker(poly.getVertex(0),{icon:car});          
              map.addOverlay(marker);          
              var steptext = map.direction.getRoute(0).getStep(stepnum).getDescriptionHtml();          
              document.getElementById("step").innerHTML = steptext;          
              setTimeout("animate(0)",2000);  // Allow time for the initial map display
          
            });          
          
            google.maps.event.addListener(map.direction,"error", function() {
              alert("Location(s) not recognised. Code: "+map.direction.getStatus().code);          
            });                   
          
            function start() {
          
              var startpoint = document.getElementById("startpoint").value;          
              var endpoint = document.getElementById("endpoint").value;          
              map.direction.loadFromWaypoints([startpoint,endpoint],{getPolyline:true,getSteps:true});          
            }   
          }
          //]]>
          
        </script>
      </span>
    </div>
  </body>
</html>